<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>○×ゲーム（消える手ルール）— AI強化・AI vs AI 対応</title>
<style>
  :root{
    --bg:#071022;
    --panel:#eaf2fb;
    --board:#ffffff;
    --line:#ccd8e6;
    --x-color:#0b63c6;
    --o-color:#c61b7a;
    --text-dark:#0b1220;
  }
  *{box-sizing:border-box}
  body{
    margin:0; min-height:100vh;
    display:flex;align-items:center;justify-content:center;
    background:linear-gradient(180deg,var(--bg) 0%, #05111a 100%);
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif;
  }
  .wrap{
    width:min(920px,96vw); background:var(--panel); border-radius:14px; padding:18px; color:var(--text-dark);
    box-shadow: 0 10px 30px rgba(2,6,23,0.45);
  }
  h1{ margin:0 0 6px; font-size:20px }
  .meta{ color:#6b7d8f; font-size:13px; margin-bottom:12px }
  .controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:12px }
  .leftControls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  button, select{
    background:#ffffff; border:1px solid var(--line); padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:700;
  }
  button.disabled{ opacity:.5; cursor:not-allowed; }
  .modeBtn.active{ background:#e1f0ff; border-color:#9fc7ff }
  .container{ display:flex; gap:18px; flex-wrap:wrap; align-items:flex-start; }
  .boardWrap{ background:linear-gradient(180deg,#f9fbff, #f0f6ff); padding:14px; border-radius:12px; border:1px solid var(--line) }
  .board{
    width:min(520px,56vw);
    aspect-ratio:1/1;
    display:grid;
    grid-template-columns:repeat(3,1fr);
    grid-auto-rows:1fr; /* これで縦横で正方形セルを維持 */
    gap:10px;
    background:var(--board); padding:6px; border-radius:10px;
    box-shadow: 0 6px 18px rgba(10,20,40,0.06) inset;
  }
  .cell{
    display:flex;align-items:center;justify-content:center;font-weight:900;font-size:clamp(36px,8vw,72px);
    border-radius:10px; background:linear-gradient(180deg,#ffffff,#f3f7ff); border:1px solid var(--line);
    user-select:none; cursor:pointer;
  }
  .cell.taken{ cursor:not-allowed; opacity:0.96 }
  .cell.x{ color:var(--x-color) }
  .cell.o{ color:var(--o-color) }
  .info{ min-width:200px; max-width:280px }
  .status{ font-weight:800; margin-top:6px; }
  .small{ color:#6b7d8f; font-size:13px; margin-top:8px }
  .aiRow{ display:flex; gap:8px; align-items:center; margin-top:6px; }
  .aiRow select{ font-weight:600; }
  .footer{ display:flex; justify-content:space-between; align-items:center; margin-top:12px; flex-wrap:wrap; gap:8px }
  @media(max-width:820px){ .container{ flex-direction:column; align-items:center } .info{ width:100% } }
</style>
</head>
<body>
  <div class="wrap">
    <h1>４手目で１手目が消える ○×ゲーム</h1>
    <div class="meta">ルール：一人が盤上に持てる印は最大3個。4手目を置くとそのプレイヤーの最古の手が消えます。</div>

    <div class="controls">
      <div class="leftControls">
        <button id="pvpBtn" class="modeBtn active">対人（CPU OFF）</button>
        <button id="mediumBtn" class="modeBtn">中級CPU</button>
        <button id="strongBtn" class="modeBtn">最強CPU</button>
      </div>

      <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
        <button id="resetBtn">リセット</button>
        <button id="swapBtn">先手/後手 入れ替え</button>
      </div>
    </div>

    <div class="container">
      <div class="boardWrap" aria-hidden="false">
        <div class="board" id="board" role="grid" aria-label="tic tac toe board"></div>
        <div class="status" id="status">先手（X）の番です</div>
      </div>

      <div class="info">
        <div style="font-weight:800">AI vs AI（自動対戦）</div>
        <div class="aiRow">
          <label>X (左) モード：
            <select id="aiX">
              <option value="OFF">OFF</option>
              <option value="MEDIUM">MEDIUM</option>
              <option value="STRONG">STRONG</option>
            </select>
          </label>
        </div>
        <div class="aiRow">
          <label>O (右) モード：
            <select id="aiO">
              <option value="OFF">OFF</option>
              <option value="MEDIUM">MEDIUM</option>
              <option value="STRONG">STRONG</option>
            </select>
          </label>
        </div>
        <div style="margin-top:8px; display:flex; gap:8px;">
          <button id="startAiVsAi">AI vs AI 開始</button>
          <button id="stopAiVsAi" class="disabled">停止</button>
        </div>
        <div class="small">※ AI vs AI 中は手動で打てません。モード切替はゲーム初期化後に有効です。</div>
        <div style="height:10px"></div>
        <div style="font-weight:700; margin-top:6px">現在のモード（簡易表示）</div>
        <div class="small" id="currentMode">CPU: OFF</div>
      </div>
    </div>

    <div class="footer">
      <div class="small">X: 先手　O: 後手</div>
      <div class="small">（MiniMaxは消える手ルールを含めて探索します）</div>
    </div>
  </div>

<script>
/* ---------- 定数とDOM ---------- */
const LINES = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const pvpBtn = document.getElementById('pvpBtn');
const mediumBtn = document.getElementById('mediumBtn');
const strongBtn = document.getElementById('strongBtn');
const resetBtn = document.getElementById('resetBtn');
const swapBtn = document.getElementById('swapBtn');
const aiXSelect = document.getElementById('aiX');
const aiOSelect = document.getElementById('aiO');
const startAiVsAiBtn = document.getElementById('startAiVsAi');
const stopAiVsAiBtn = document.getElementById('stopAiVsAi');
const currentModeEl = document.getElementById('currentMode');

let state = null;
let cpuMode = 'OFF'; // 'OFF' | 'MEDIUM' | 'STRONG'
let startingTurn = 'X';
let aiVsAiRunning = false;

/* ---------- state helpers ---------- */
function makeEmptyState(start='X'){
  return {
    board: Array(9).fill(null),
    xQueue: [],
    oQueue: [],
    turn: start,
    playing: true
  };
}
function cloneState(s){
  return {
    board: s.board.slice(),
    xQueue: s.xQueue.slice(),
    oQueue: s.oQueue.slice(),
    turn: s.turn,
    playing: s.playing
  };
}
function applyMoveInPlace(s, idx, player){
  s.board[idx] = player;
  const q = (player === 'X') ? s.xQueue : s.oQueue;
  q.push(idx);
  if(q.length > 3){
    const oldest = q.shift();
    s.board[oldest] = null;
  }
}
function simulateMove(s, idx, player){
  const ns = cloneState(s);
  applyMoveInPlace(ns, idx, player);
  ns.turn = (player === 'X') ? 'O' : 'X';
  return ns;
}
function emptyIndices(s){
  return s.board.map((v,i)=> v ? null : i).filter(v=>v!==null);
}
function isWinBoard(board, player){
  return LINES.some(line => line.every(i => board[i] === player));
}
function stateIsWin(s, player){
  return isWinBoard(s.board, player);
}

/* ---------- DOM render ---------- */
function renderBoardDOM(){
  boardEl.innerHTML = '';
  for(let i=0;i<9;i++){
    const div = document.createElement('div');
    div.className = 'cell';
    div.dataset.index = i;
    div.addEventListener('click', ()=>onCellClick(i));
    boardEl.appendChild(div);
  }
  refreshBoardDOM();
}
function refreshBoardDOM(){
  for(let i=0;i<9;i++){
    const div = boardEl.querySelector(`[data-index="${i}"]`);
    const v = state.board[i];
    div.textContent = v || '';
    div.classList.toggle('taken', !!v);
    div.classList.toggle('x', v === 'X');
    div.classList.toggle('o', v === 'O');
  }
  updateStatusText();
  currentModeEl.textContent = `CPU mode: ${cpuMode}  |  AI X:${aiXSelect.value}  O:${aiOSelect.value}`;
}

/* ---------- player actions ---------- */
function onCellClick(idx){
  if(!state.playing) return;
  if(state.board[idx]) return;
  // if AI vs AI running or CPU is controlling this side, disallow manual click
  if(aiVsAiRunning) return;
  if(cpuMode !== 'OFF' && state.turn === 'O' && cpuMode === 'MEDIUM' || cpuMode === 'STRONG') {
    // The UI mode buttons set global cpuMode — but for manual play we only block O if cpuMode is ON
  }
  // if cpuMode is not OFF and O is controlled by CPU, block clicks on O-turn
  if(cpuMode !== 'OFF' && state.turn === 'O') return;

  applyMoveInPlace(state, idx, state.turn);
  refreshBoardDOM();
  if(stateIsWin(state, state.turn)){
    state.playing = false;
    statusEl.textContent = state.turn + ' の勝ち！';
    return;
  }
  state.turn = (state.turn === 'X') ? 'O' : 'X';
  refreshBoardDOM();
  if(cpuMode !== 'OFF' && state.turn === 'O'){
    // let CPU play after a small delay
    setTimeout(()=>cpuMoveWrapper(cpuMode), 220);
  }
}

/* ---------- CPU wrapper ---------- */
function cpuMoveWrapper(mode){
  if(mode === 'MEDIUM') {
    const idx = computeMoveMedium(state, 'O');
    if(idx !== null){ applyMoveInPlace(state, idx, 'O'); }
  } else if(mode === 'STRONG') {
    const idx = computeMoveStrong(state, 'O');
    if(idx !== null){ applyMoveInPlace(state, idx, 'O'); }
  }
  refreshBoardDOM();
  if(stateIsWin(state, 'O')){ state.playing = false; statusEl.textContent = 'O の勝ち！'; return; }
  state.turn = 'X';
  refreshBoardDOM();
}

/* ---------- MEDIUM AI（手を返す） ---------- */
function findImmediateWinningMoveForState(s, player){
  const empties = emptyIndices(s);
  for(const idx of empties){
    const ns = simulateMove(s, idx, player);
    if(stateIsWin(ns, player)) return idx;
  }
  return null;
}
function chooseBySurvivalPriorityForState(s, player){
  // player is 'O' or 'X'. We'll prefer moves that don't remove our valuable marks and avoid giving opponent immediate win.
  const empties = emptyIndices(s);
  let best = null; let bestScore = -Infinity;
  for(const idx of empties){
    const ns = simulateMove(s, idx, player);
    // if opponent can immediate-win after this, heavy penalty
    const opponent = player === 'O' ? 'X' : 'O';
    if(findImmediateWinningMoveForState(ns, opponent) !== null) continue;
    // measure removal: how many of player's previous positions lost?
    const origQueue = (player==='O') ? s.oQueue.slice() : s.xQueue.slice();
    const afterQueue = (player==='O') ? ns.oQueue.slice() : ns.xQueue.slice();
    let removed = 0;
    for(const v of origQueue) if(!afterQueue.includes(v)) removed++;
    let score = 0;
    if(removed === 0) score += 10;
    else if(removed === 1) score += 2;
    // positional bias
    if(idx === 4) score += 3;
    if([0,2,6,8].includes(idx)) score += 1;
    if(score > bestScore){ bestScore = score; best = idx; }
  }
  return best;
}
function computeMoveMedium(s, player){
  // 1) immediate win
  let move = findImmediateWinningMoveForState(s, player);
  if(move !== null) return move;
  // 2) block opponent's immediate win
  const opponent = (player === 'O') ? 'X' : 'O';
  move = findImmediateWinningMoveForState(s, opponent);
  if(move !== null) return move;
  // 3) survival-priority
  move = chooseBySurvivalPriorityForState(s, player);
  if(move !== null) return move;
  // 4) center -> corners -> any
  if(s.board[4] === null) return 4;
  const corners = [0,2,6,8].filter(i=>s.board[i]===null);
  if(corners.length) return corners[Math.floor(Math.random()*corners.length)];
  const empties = emptyIndices(s);
  if(empties.length) return empties[0];
  return null;
}

/* ---------- STRONG AI（MiniMax with removal, returns best idx） ---------- */
const memo = new Map();
function stateKey(s){
  // include queue orders
  return JSON.stringify({b:s.board, xq:s.xQueue, oq:s.oQueue, t:s.turn});
}
function terminalScore(s, depth){
  if(stateIsWin(s, 'O')) return 100 - depth;
  if(stateIsWin(s, 'X')) return -100 + depth;
  if(emptyIndices(s).length === 0) return 0;
  return null;
}
function heuristicEval(s){
  let score = 0;
  for(const line of LINES){
    const marks = line.map(i=>s.board[i]);
    const oCount = marks.filter(m=>m==='O').length;
    const xCount = marks.filter(m=>m==='X').length;
    if(xCount === 0 && oCount > 0) score += Math.pow(10, oCount);
    if(oCount === 0 && xCount > 0) score -= Math.pow(10, xCount);
  }
  return score;
}
function minimaxValue(s, depth, alpha, beta, maximizingPlayer){
  const t = terminalScore(s, depth);
  if(t !== null) return t;
  const key = stateKey(s);
  if(memo.has(key)) return memo.get(key);
  const MAX_DEPTH = 14; // safety cap
  if(depth >= MAX_DEPTH){
    const h = heuristicEval(s);
    memo.set(key, h);
    return h;
  }
  const empties = emptyIndices(s);
  if(maximizingPlayer){
    let best = -Infinity;
    for(const idx of empties){
      const ns = simulateMove(s, idx, 'O');
      const val = minimaxValue(ns, depth+1, alpha, beta, false);
      if(val > best) best = val;
      if(best > alpha) alpha = best;
      if(beta <= alpha) break;
    }
    memo.set(key, best);
    return best;
  } else {
    let best = Infinity;
    for(const idx of empties){
      const ns = simulateMove(s, idx, 'X');
      const val = minimaxValue(ns, depth+1, alpha, beta, true);
      if(val < best) best = val;
      if(best < beta) beta = best;
      if(beta <= alpha) break;
    }
    memo.set(key, best);
    return best;
  }
}
function computeMoveStrong(s, player){
  // player is assumed 'O' or 'X' — we will run minimax with appropriate maximizing/minimizing
  memo.clear();
  const empties = emptyIndices(s);
  if(empties.length === 0) return null;
  let bestMove = null;
  let bestVal = (player === 'O') ? -Infinity : Infinity;
  for(const idx of empties){
    const ns = simulateMove(s, idx, player);
    const val = minimaxValue(ns, 0, -Infinity, Infinity, player === 'X' ? false : false);
    // if player is 'O' we want max; if 'X' we want min — but here for AI usage, we'll normally call with 'O'
    if(player === 'O'){
      if(val > bestVal){ bestVal = val; bestMove = idx; }
    } else {
      if(val < bestVal){ bestVal = val; bestMove = idx; }
    }
  }
  // fallback
  if(bestMove === null) return empties[0];
  return bestMove;
}

/* ---------- AI vs AI runner ---------- */
let aiVsAiStopRequested = false;
async function runAiVsAi(){
  if(aiVsAiRunning) return;
  aiVsAiRunning = true;
  aiVsAiStopRequested = false;
  startAiVsAiBtn.disabled = true;
  stopAiVsAiBtn.classList.remove('disabled');
  stopAiVsAiBtn.disabled = false;
  // use selections for X and O
  const modeX = aiXSelect.value;
  const modeO = aiOSelect.value;
  // reset to startingTurn
  init(startingTurn);
  // loop until game end or stop requested
  while(state.playing && !aiVsAiStopRequested){
    await new Promise(r => setTimeout(r, 300)); // small delay for readability
    const cur = state.turn;
    let chosen = null;
    if(cur === 'X'){
      if(modeX === 'OFF') break; // human expected, stop
      if(modeX === 'MEDIUM') chosen = computeMoveMedium(state, 'X');
      else if(modeX === 'STRONG') chosen = computeMoveStrong(state, 'X');
    } else {
      if(modeO === 'OFF') break;
      if(modeO === 'MEDIUM') chosen = computeMoveMedium(state, 'O');
      else if(modeO === 'STRONG') chosen = computeMoveStrong(state, 'O');
    }
    if(chosen === null){ // no moves
      break;
    }
    applyMoveInPlace(state, chosen, cur);
    refreshBoardDOM();
    if(stateIsWin(state, cur)){
      state.playing = false;
      statusEl.textContent = cur + ' の勝ち！';
      break;
    }
    state.turn = (state.turn === 'X') ? 'O' : 'X';
    refreshBoardDOM();
  }
  aiVsAiRunning = false;
  aiVsAiStopRequested = false;
  startAiVsAiBtn.disabled = false;
  stopAiVsAiBtn.classList.add('disabled');
  stopAiVsAiBtn.disabled = true;
}

/* ---------- UI and mode handling ---------- */
function setMode(mode){
  cpuMode = mode;
  pvpBtn.classList.toggle('active', mode === 'OFF');
  mediumBtn.classList.toggle('active', mode === 'MEDIUM');
  strongBtn.classList.toggle('active', mode === 'STRONG');
  init(startingTurn);
}
pvpBtn.addEventListener('click', ()=> setMode('OFF'));
mediumBtn.addEventListener('click', ()=> setMode('MEDIUM'));
strongBtn.addEventListener('click', ()=> setMode('STRONG'));
resetBtn.addEventListener('click', ()=> init(startingTurn));
swapBtn.addEventListener('click', ()=>{
  startingTurn = (startingTurn === 'X') ? 'O' : 'X';
  init(startingTurn);
});

/* AI vs AI buttons */
startAiVsAiBtn.addEventListener('click', ()=>{
  // prevent manual CPU global mode interfering while AI vs AI runs
  aiVsAiRunning = false;
  runAiVsAi();
});
stopAiVsAiBtn.addEventListener('click', ()=>{
  aiVsAiStopRequested = true;
});

/* ---------- simple CPU button mode for single-player: if user selects Medium/Strong top buttons, O is CPU ---------- */
function maybeTriggerCpuOnStart(){
  if(cpuMode !== 'OFF' && state.turn === 'O'){
    setTimeout(()=>cpuMoveWrapper(cpuMode), 250);
  }
}

/* ---------- status update ---------- */
function updateStatusText(){
  if(!state.playing) return;
  statusEl.textContent = (state.turn === 'X') ? '先手（X）の番です' : '先手（O）の番です';
}

/* ---------- init ---------- */
function init(start='X'){
  state = makeEmptyState(start);
  renderBoardDOM();
  // clear minimax memo
  memo.clear();
  // reset UI buttons stop flags
  aiVsAiStopRequested = true;
  aiVsAiRunning = false;
  stopAiVsAiBtn.classList.add('disabled');
  stopAiVsAiBtn.disabled = true;
  startAiVsAiBtn.disabled = false;
  refreshBoardDOM();
  // if CPU single-player mode engaged and O to move, run CPU
  maybeTriggerCpuOnStart();
}

/* ---------- startup ---------- */
setMode('OFF');
init(startingTurn);

</script>
</body>
</html>
